<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Central Térmica (Estilo Modelica)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .component-library-item {
            transition: all 0.2s ease-in-out;
        }
        .component-library-item:hover {
            transform: scale(1.05);
            background-color: #e0f2fe; /* light blue hover */
        }
        canvas {
            background-color: #f8fafc; /* cool gray 50 */
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0; /* cool gray 200 */
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        .param-input {
            @apply w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm;
        }
        #table-modal, #validation-modal, #chart-modal, #variable-load-modal {
            background-color: rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s ease;
        }
        #data-table-container table {
            width: 100%;
            text-align: left;
            font-size: 0.875rem; /* text-sm */
            color: #6b7280; /* text-gray-500 */
            border-collapse: collapse;
        }
        #data-table-container th, #data-table-container td {
            padding: 0.75rem; /* p-3 */
            border: 1px solid #9ca3af; /* border-gray-400 */
        }
        #data-table-container th {
            font-size: 0.75rem; /* text-xs */
            font-weight: 600; /* font-semibold */
            color: white;
            text-transform: uppercase;
            background-color: #1f2937; /* bg-gray-800 */
        }
        #data-table-container td {
            color: #374151; /* text-gray-700 */
        }
        #data-table-container tbody tr:nth-child(even) {
            background-color: #f9fafb; /* bg-gray-50 */
        }
        #data-table-container tbody tr:hover {
            background-color: #dbeafe; /* bg-blue-100 */
        }
        .speed-btn {
             @apply px-2 py-1 text-xs font-medium rounded-md transition;
        }
        .speed-btn-active {
            background-color: #2563eb; /* bg-blue-600 */
            color: white;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transform: scale(1.05);
        }
        .speed-btn-inactive {
            background-color: #e5e7eb; /* bg-gray-200 */
            color: #374151; /* text-gray-700 */
        }
        .speed-btn-inactive:hover {
             background-color: #d1d5db; /* hover:bg-gray-300 */
        }
        .tab-btn {
            @apply px-4 py-2 text-sm font-medium text-gray-500 border-b-2 border-transparent hover:text-gray-700 hover:border-gray-300;
        }
        .tab-btn-active {
            @apply text-blue-600 border-blue-600;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col h-screen overflow-hidden">

    <!-- Header -->
    <header class="bg-white shadow-md p-4 flex justify-between items-center z-20 flex-wrap gap-y-2">
        <h1 class="text-2xl font-bold text-gray-700 mr-6">Simulador de Central Térmica</h1>
        <div class="flex items-center space-x-2 bg-gray-100 p-2 rounded-lg">
            <div class="text-center px-2">
                <div class="text-xs font-semibold text-gray-500">ENERGIA TÉRMICA</div>
                <div id="totalTermicaDisplay" class="text-lg font-bold text-blue-600">0.0 kWh</div>
            </div>
            <div class="border-l h-8"></div>
            <div class="text-center px-2">
                <div class="text-xs font-semibold text-gray-500">CONSUMO ELÉTRICO</div>
                <div id="totalEletricoDisplay" class="text-lg font-bold text-green-600">0.0 kWh</div>
            </div>
            <div class="border-l h-8"></div>
            <div class="text-center px-2">
                <div class="text-xs font-semibold text-gray-500">GÁS NATURAL</div>
                <div id="totalGasNaturalDisplay" class="text-lg font-bold text-yellow-600">0.0 kWh</div>
            </div>
            <div class="border-l h-8"></div>
            <div class="text-center px-2">
                <div class="text-xs font-semibold text-gray-500">PROPANO</div>
                <div id="totalPropanoDisplay" class="text-lg font-bold text-gray-600">0.0 kWh</div>
            </div>
        </div>
        <div class="flex items-center space-x-2 mt-2 sm:mt-0 flex-wrap">
             <div class="flex items-center space-x-2">
                <label for="tempExterior" class="text-sm font-medium text-gray-700">Temp. Ext. (°C):</label>
                <input type="number" id="tempExterior" value="10" class="w-20 p-1 border border-gray-300 rounded-md shadow-sm sm:text-sm">
            </div>
            <button id="showTableBtn" class="bg-gray-500 text-white font-semibold px-4 py-2 rounded-lg shadow hover:bg-gray-600 transition duration-300">Tabela</button>
            <button id="showChartBtn" class="bg-purple-500 text-white font-semibold px-4 py-2 rounded-lg shadow hover:bg-purple-600 transition duration-300">Gráfico</button>
            <button id="simulateSteadyBtn" class="bg-blue-600 text-white font-semibold px-4 py-2 rounded-lg shadow hover:bg-blue-700 transition duration-300">Sim. Steady</button>
            <div class="flex items-center space-x-2 bg-gray-100 p-1 rounded-lg">
                 <button id="startDynamicBtn" class="bg-teal-500 text-white font-semibold px-4 py-1 rounded-lg shadow hover:bg-teal-600 transition duration-300">Sim. Dinâmica</button>
                 <button id="pauseDynamicBtn" class="hidden bg-orange-500 text-white font-semibold px-4 py-1 rounded-lg shadow hover:bg-orange-600 transition duration-300">Parar</button>
                 <div id="dynamicTimeDisplay" class="text-sm font-mono text-gray-700 px-2 w-48 text-center">Hora: 0 H</div>
                 <div class="flex items-center border-l pl-2 ml-2">
                    <span class="text-xs font-medium text-gray-600 mr-2">Velocidade:</span>
                    <div id="speed-selector" class="flex items-center space-x-1">
                        <button data-speed="1000" class="speed-btn speed-btn-active">1×</button>
                        <button data-speed="100" class="speed-btn speed-btn-inactive">10×</button>
                        <button data-speed="10" class="speed-btn speed-btn-inactive">100×</button>
                        <button data-speed="2" class="speed-btn speed-btn-inactive">500×</button>
                        <button data-speed="1" class="speed-btn speed-btn-inactive">1000×</button>
                    </div>
                 </div>
            </div>
            <button id="clearResultsBtn" class="bg-yellow-500 text-white font-semibold px-4 py-2 rounded-lg shadow hover:bg-yellow-600 transition duration-300">Limpar Resultados</button>
            <button id="clearBtn" class="bg-red-500 text-white font-semibold px-4 py-2 rounded-lg shadow hover:bg-red-600 transition duration-300">Limpar Área de Trabalho</button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
        <!-- Component Library -->
        <aside id="component-library" class="w-64 bg-white p-4 overflow-y-auto shadow-lg transition-all duration-300">
            <h2 class="text-lg font-semibold mb-4 text-gray-600 border-b pb-2">Biblioteca de Equipamentos</h2>
            <!-- Component categories will be injected here by JS -->
        </aside>

        <!-- Workspace -->
        <main class="flex-1 p-4 bg-gray-50 flex flex-col">
            <div id="canvas-container" class="relative flex-1 w-full h-full border-dashed border-2 border-gray-300 rounded-lg">
                <canvas id="workspace"></canvas>
                <div id="message-box" class="hidden absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-yellow-100 border border-yellow-400 text-yellow-700 px-4 py-3 rounded-lg shadow-lg z-20" role="alert">
                    <strong class="font-bold">Aviso:</strong>
                    <span class="block sm:inline" id="message-text"></span>
                </div>
            </div>
             <p class="text-xs text-gray-500 text-center mt-2">Dica: Clique numa ligação ou equipamento e pressione a tecla 'Delete' para apagar.</p>
        </main>
        
        <!-- Properties Panel -->
        <aside id="properties-panel" class="w-0 bg-white p-0 overflow-y-auto shadow-lg transition-all duration-300 z-10">
            <!-- Content will be injected by JS -->
        </aside>
    </div>

    <!-- Data Table Modal -->
    <div id="table-modal" class="hidden fixed inset-0 z-30 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-7xl max-h-[80vh] flex flex-col">
            <header class="p-4 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold text-gray-700">Tabela de Equipamentos e Dados</h2>
                <button id="close-table-modal-btn" class="text-gray-400 hover:text-gray-600 text-2xl font-bold">&times;</button>
            </header>
            <main id="data-table-container" class="p-4 overflow-y-auto"></main>
        </div>
    </div>
    
    <!-- Chart Modal -->
    <div id="chart-modal" class="hidden fixed inset-0 z-30 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-4xl h-[70vh] flex flex-col">
            <header class="p-4 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold text-gray-700">Gráfico de Energia Acumulada</h2>
                <button id="close-chart-modal-btn" class="text-gray-400 hover:text-gray-600 text-2xl font-bold">&times;</button>
            </header>
            <main class="p-4 flex-1 relative">
                <canvas id="chart-canvas"></canvas>
            </main>
        </div>
    </div>

    <!-- Validation Modal -->
    <div id="validation-modal" class="hidden fixed inset-0 z-30 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-lg">
            <header class="p-4 border-b flex justify-between items-center bg-red-500 text-white">
                <h2 class="text-xl font-bold">Erro de Validação do Circuito</h2>
                <button id="close-validation-modal-btn" class="text-white hover:text-gray-200 text-2xl font-bold">&times;</button>
            </header>
            <main id="validation-message-container" class="p-6">
                <p class="text-gray-700 mb-4">A simulação não pode continuar. Por favor, corrija os seguintes problemas:</p>
                <ul id="validation-errors-list" class="list-disc list-inside space-y-2 text-red-700">
                    <!-- Errors will be injected here -->
                </ul>
            </main>
        </div>
    </div>

    <!-- Variable Load Modal -->
    <div id="variable-load-modal" class="hidden fixed inset-0 z-40 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-4xl h-[90vh] flex flex-col">
            <header class="p-4 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold text-gray-700">Editar Carga Variável</h2>
                <button id="close-load-modal-btn" class="text-gray-400 hover:text-gray-600 text-2xl font-bold">&times;</button>
            </header>
            <main class="p-4 flex-1 flex flex-col md:flex-row gap-4 overflow-hidden">
                <!-- Left side: Inputs -->
                <div class="w-full md:w-1/2 flex flex-col">
                    <div class="border-b border-gray-200">
                        <nav id="load-profile-tabs" class="-mb-px flex space-x-4" aria-label="Tabs">
                            <button data-tab="diario" class="tab-btn tab-btn-active">Perfil Diário</button>
                            <button data-tab="anual" class="tab-btn">Importar Anual</button>
                        </nav>
                    </div>
                    <div id="load-tab-content-diario" class="py-4 overflow-y-auto flex-1">
                         <p class="text-sm text-gray-600 mb-4">Insira a carga em Watts para cada hora do dia. O gráfico será atualizado automaticamente.</p>
                         <div id="daily-load-inputs" class="grid grid-cols-4 gap-x-4 gap-y-2">
                            <!-- 24 inputs will be generated here by JS -->
                         </div>
                         <div class="mt-4 pt-2 border-t text-right">
                            <span class="text-sm font-medium text-gray-600">Total Diário: </span>
                            <span id="daily-load-total" class="text-lg font-bold text-indigo-600">0.00</span>
                            <span class="text-sm text-gray-500">kWh</span>
                        </div>
                    </div>
                    <div id="load-tab-content-anual" class="hidden py-4 flex-1 flex flex-col">
                        <label for="modal-param-perfilAnual" class="block text-sm font-medium text-gray-700">Perfil Anual (8760h em W)</label>
                        <textarea id="modal-param-perfilAnual" rows="10" class="param-input mt-1 flex-1" placeholder="8760 valores em Watts, separados por vírgula..."></textarea>
                        <div class="mt-2 pt-2 border-t text-right">
                            <span class="text-sm font-medium text-gray-600">Total Anual: </span>
                            <span id="annual-load-total" class="text-lg font-bold text-indigo-600">0.00</span>
                            <span class="text-sm text-gray-500">kWh</span>
                        </div>
                    </div>
                </div>
                <!-- Right side: Chart -->
                <div class="w-full md:w-1/2 flex flex-col">
                     <h3 id="load-chart-title" class="text-md font-semibold text-gray-600 mb-2">Visualização do Perfil Diário</h3>
                     <div class="relative flex-1 bg-gray-50 p-2 rounded-lg">
                        <canvas id="load-chart-canvas"></canvas>
                     </div>
                </div>
            </main>
            <footer class="p-4 border-t flex justify-end">
                <button id="save-load-modal-btn" class="bg-blue-600 text-white font-semibold px-4 py-2 rounded-lg shadow hover:bg-blue-700 transition">Guardar e Fechar</button>
            </footer>
        </div>
    </div>


    <script type="module">
        // --- CONFIGURAÇÃO E CONSTANTES ---
        const COMPONENT_WIDTH = 150;
        const COMPONENT_HEIGHT = 95; // Increased height
        const CONNECTOR_RADIUS = 8;
        const SPECIFIC_HEAT_WATER = 4186; // J/kg°C
        const GRID_SIZE = 20;

        // --- DEFINIÇÃO DOS COMPONENTES ---
        const componentTemplates = {
            'Caldeira': { category: 'Produção', color: '#22c55e', params: { potencia: 100000, tempSaida: 80, rendimento: 0.9, potEletrica: 200, fuelType: 'Gás Natural', perdaCarga: 5 }, inputs: ['entrada'], outputs: ['saida'] },
            'Bomba de Calor': { category: 'Produção', color: '#16a34a', params: { potencia: 25000, COP: 4.0, perdaCarga: 5 }, inputs: ['entrada'], outputs: ['saida'] },
            'Chiller': { category: 'Produção', color: '#0ea5e9', params: { potencia: 50000, EER: 3.5, perdaCarga: 5, tempSaida: 7 }, inputs: ['entrada'], outputs: ['saida'] },
            'Produtor Genérico': { category: 'Produção', color: '#f43f5e', params: { potencia: 10000, cargaVariavel: false, perfilDiario: '', perfilAnual: '', energySource: 'Eletricidade', perdaCarga: 5 }, inputs: ['entrada'], outputs: ['saida'] },
            'Bomba': { category: 'Impulsão', color: '#3b82f6', params: { caudal: 2.0, potEletrica: 500, alturaManometrica: 100 }, inputs: ['entrada'], outputs: ['saida'] },
            'Tubo': { category: 'Distribuição', color: '#64748b', params: { comprimento: 10, perdaTermica: 0.5, perdaCarga: 2 }, inputs: ['entrada'], outputs: ['saida'] },
            'Depósito de Inércia': { category: 'Distribuição', color: '#a855f7', params: { volume: 500, perdaCarga: 3 }, inputs: ['entrada'], outputs: ['saida'] },
            'Permutador': { category: 'Distribuição', color: '#84cc16', params: { potencia: 15000, tipo: 'Placas', perdaCarga: 15 }, inputs: ['primario_in', 'secundario_in'], outputs: ['primario_out', 'secundario_out'] },
            'Coletor': { category: 'Distribuição', color: '#78716c', params: { numEntradas: 2, numSaidas: 2, perdaCarga: 1 }, inputs: ['in1', 'in2'], outputs: ['out1', 'out2'] },
            'Válvula de Regulação': { category: 'Distribuição', color: '#eab308', params: { abertura: 100, perdaCarga: 2 }, inputs: ['entrada'], outputs: ['saida'] },
            'Radiador': { category: 'Consumo', color: '#ef4444', params: { potencia: 5000, cargaVariavel: false, perfilDiario: '', perfilAnual: '', perdaCarga: 10 }, inputs: ['entrada'], outputs: ['saida'] },
            'Unidade de Tratamento de Ar': { category: 'Consumo', color: '#dc2626', params: { potencia: 20000, potEletrica: 1500, cargaVariavel: false, perfilDiario: '', perfilAnual: '', perdaCarga: 10 }, inputs: ['entrada'], outputs: ['saida'] },
            'Carga Genérica': { category: 'Consumo', color: '#be123c', params: { potencia: 15000, cargaVariavel: false, perfilDiario: '', perfilAnual: '', perdaCarga: 10 }, inputs: ['entrada'], outputs: ['saida'] },
            'Acumulador': { category: 'Acumulação', color: '#f97316', params: { volume: 500, perdaCarga: 3 }, inputs: ['entrada'], outputs: ['saida'] }
        };

        // --- ESTADO DA APLICAÇÃO ---
        let components = []; let connections = []; let nextId = 0;
        let draggingComponent = null; let connectingFrom = null; let selectedComponent = null; let selectedConnection = null;
        let mouse = { x: 0, y: 0, down: false, dragMoved: false };
        let steadyResultsAvailable = false;
        let dynamicSimState = { 
            running: false, intervalId: null, hour: 0, speed: 1000, 
            totalTermica: 0, totalEletrica: 0, totalGasNatural: 0, totalPropano: 0,
            monthlyThermal: Array(12).fill(0), monthlyElectric: Array(12).fill(0),
            monthlyGasNatural: Array(12).fill(0), monthlyPropano: Array(12).fill(0)
        };
        let viewTransform = { scale: 1, offsetX: 0, offsetY: 0 };
        let panning = { active: false, startX: 0, startY: 0 };
        let chartInstance = null;
        let loadChartInstance = null;
        let editingLoadComponent = null;

        // --- SETUP DO CANVAS E DOM ---
        const canvas = document.getElementById('workspace'); const ctx = canvas.getContext('2d');
        const libraryContainer = document.getElementById('component-library');
        const simulateSteadyBtn = document.getElementById('simulateSteadyBtn');
        const startDynamicBtn = document.getElementById('startDynamicBtn');
        const pauseDynamicBtn = document.getElementById('pauseDynamicBtn');
        const dynamicTimeDisplay = document.getElementById('dynamicTimeDisplay');
        const showTableBtn = document.getElementById('showTableBtn');
        const showChartBtn = document.getElementById('showChartBtn');
        const clearBtn = document.getElementById('clearBtn');
        const clearResultsBtn = document.getElementById('clearResultsBtn');
        const messageBox = document.getElementById('message-box'); const messageText = document.getElementById('message-text');
        const tableModal = document.getElementById('table-modal');
        const closeTableModalBtn = document.getElementById('close-table-modal-btn');
        const chartModal = document.getElementById('chart-modal');
        const closeChartModalBtn = document.getElementById('close-chart-modal-btn');
        const chartCanvas = document.getElementById('chart-canvas').getContext('2d');
        const validationModal = document.getElementById('validation-modal');
        const closeValidationModalBtn = document.getElementById('close-validation-modal-btn');
        const validationErrorsList = document.getElementById('validation-errors-list');
        const propertiesPanel = document.getElementById('properties-panel');
        const speedSelector = document.getElementById('speed-selector');
        const totalTermicaDisplay = document.getElementById('totalTermicaDisplay');
        const totalEletricoDisplay = document.getElementById('totalEletricoDisplay');
        const totalGasNaturalDisplay = document.getElementById('totalGasNaturalDisplay');
        const totalPropanoDisplay = document.getElementById('totalPropanoDisplay');
        const variableLoadModal = document.getElementById('variable-load-modal');
        const closeLoadModalBtn = document.getElementById('close-load-modal-btn');
        const saveLoadModalBtn = document.getElementById('save-load-modal-btn');
        const loadChartCanvas = document.getElementById('load-chart-canvas').getContext('2d');
        const dailyLoadInputsContainer = document.getElementById('daily-load-inputs');
        const modalAnnualProfileTextarea = document.getElementById('modal-param-perfilAnual');
        const loadChartTitle = document.getElementById('load-chart-title');
        const dailyLoadTotalSpan = document.getElementById('daily-load-total');
        const annualLoadTotalSpan = document.getElementById('annual-load-total');
        
        // --- HELPERS (TRANSFORMAÇÃO E GRELHA) ---
        function getComponentHeight(comp) {
            if (comp.type === 'Coletor') {
                const numConnectors = Math.max(comp.inputs?.length || 1, comp.outputs?.length || 1);
                return 40 + numConnectors * 25; // Base height + spacing per connector
            }
            return COMPONENT_HEIGHT;
        }

        function screenToWorld(x, y) {
            return {
                x: (x - viewTransform.offsetX) / viewTransform.scale,
                y: (y - viewTransform.offsetY) / viewTransform.scale,
            };
        }
        
        function getDateFromHour(hour) {
            if (hour === 0) return "Início";
            const date = new Date(2024, 0, 1); // Start of a non-leap year
            date.setHours(date.getHours() + hour - 1);
            const month = date.toLocaleString('pt-PT', { month: 'short' });
            const day = date.getDate();
            return `${day} ${month}`;
        }

        function isPointOnBezier(point, p0, p1, p2, p3, threshold = 10) {
            for (let t = 0; t <= 1; t += 0.02) {
                const x = Math.pow(1 - t, 3) * p0.x + 3 * Math.pow(1 - t, 2) * t * p1.x + 3 * (1 - t) * t * t * p2.x + t * t * t * p3.x;
                const y = Math.pow(1 - t, 3) * p0.y + 3 * Math.pow(1 - t, 2) * t * p1.y + 3 * (1 - t) * t * t * p2.y + t * t * t * p3.y;
                if (Math.hypot(point.x - x, point.y - y) < threshold / viewTransform.scale) {
                    return true;
                }
            }
            return false;
        }

        function drawGrid() {
            ctx.strokeStyle = '#e2e8f0'; // cool-gray-200
            ctx.lineWidth = 1;
            const scaledGridSize = GRID_SIZE * viewTransform.scale;
            if (scaledGridSize < 5) return;

            const startX = -viewTransform.offsetX % (GRID_SIZE * viewTransform.scale);
            const startY = -viewTransform.offsetY % (GRID_SIZE * viewTransform.scale);
            
            ctx.beginPath();
            for (let x = startX / viewTransform.scale; x < canvas.width / viewTransform.scale; x += GRID_SIZE) {
                ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height / viewTransform.scale);
            }
            for (let y = startY / viewTransform.scale; y < canvas.height / viewTransform.scale; y += GRID_SIZE) {
                ctx.moveTo(0, y); ctx.lineTo(canvas.width / viewTransform.scale, y);
            }
            ctx.stroke();
        }

        // --- LÓGICA DE DESENHO (RENDERIZAÇÃO) ---
        function setupCanvas() {
            const container = document.getElementById('canvas-container'); const dpr = window.devicePixelRatio || 1;
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width * dpr; canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = `${rect.width}px`; canvas.style.height = `${rect.height}px`;
        }

        function showMessage(msg, isError = false) {
            messageText.textContent = msg;
            messageBox.classList.remove('hidden', 'bg-yellow-100', 'border-yellow-400', 'text-yellow-700', 'bg-red-100', 'border-red-400', 'text-red-700');
            if (isError) {
                messageBox.classList.add('bg-red-100', 'border-red-400', 'text-red-700');
            } else {
                messageBox.classList.add('bg-yellow-100', 'border-yellow-400', 'text-yellow-700');
            }
            setTimeout(() => { messageBox.classList.add('hidden'); }, 4000);
        }

        function getComponentConnectors(comp, type) {
            const template = componentTemplates[comp.type];
            if (comp.type === 'Coletor' && comp.inputs && comp.outputs) {
                return type === 'input' ? comp.inputs : comp.outputs;
            }
            return type === 'input' ? template.inputs : template.outputs;
        }

        function drawComponent(comp) {
            const template = componentTemplates[comp.type];
            const height = getComponentHeight(comp);
            ctx.fillStyle = 'white';
            ctx.strokeStyle = template.color;
            if (comp === selectedComponent) {
                ctx.lineWidth = 4; ctx.shadowColor = template.color; ctx.shadowBlur = 10;
            } else {
                ctx.lineWidth = 2;
            }
            ctx.beginPath(); ctx.roundRect(comp.x, comp.y, COMPONENT_WIDTH, height, [8]); ctx.fill(); ctx.stroke();
            ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.lineWidth = 1;
            ctx.fillStyle = template.color; ctx.beginPath(); ctx.roundRect(comp.x, comp.y, COMPONENT_WIDTH, 24, [8, 8, 0, 0]); ctx.fill();
            ctx.fillStyle = 'white'; ctx.font = '600 14px Inter'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(comp.type, comp.x + COMPONENT_WIDTH / 2, comp.y + 12);

            ctx.fillStyle = '#334155';
            ctx.font = '11px Inter';
            
            if (comp.type === 'Bomba') {
                const caudal = comp.results.caudal !== null ? `${comp.results.caudal.toFixed(2)} kg/s` : '--';
                const altura = comp.params.alturaManometrica;
                const potEletrica = (comp.params.potEletrica / 1000).toFixed(2);
                ctx.fillText(caudal, comp.x + COMPONENT_WIDTH / 2, comp.y + 40);
                ctx.fillText(`Altura: ${altura} kPa`, comp.x + COMPONENT_WIDTH / 2, comp.y + 58);
                ctx.fillText(`P.Elétrica: ${potEletrica} kW`, comp.x + COMPONENT_WIDTH / 2, comp.y + 76);
            } else {
                const caudal = comp.results.caudal !== null ? `${comp.results.caudal.toFixed(2)} kg/s` : '--';
                const temp = comp.results.tempSaida !== null ? `${comp.results.tempSaida.toFixed(1)}°C` : '--';
                const pot = comp.results.potencia !== null ? `${(comp.results.potencia / 1000).toFixed(1)} kW` : '--';
                const perdaCarga = comp.params.hasOwnProperty('perdaCarga') ? `${comp.params.perdaCarga} kPa` : '--';
                ctx.fillText(caudal, comp.x + COMPONENT_WIDTH / 2, comp.y + 38);
                ctx.fillText(temp, comp.x + COMPONENT_WIDTH / 2, comp.y + 53);
                ctx.fillText(pot, comp.x + COMPONENT_WIDTH / 2, comp.y + 68);
                ctx.fillText(`ΔP: ${perdaCarga}`, comp.x + COMPONENT_WIDTH / 2, comp.y + 83);
            }

            drawConnectors(comp);
        }

        function getConnectorPos(comp, type, name) {
            const connectors = getComponentConnectors(comp, type);
            const height = getComponentHeight(comp);
            const index = connectors.indexOf(name);
            if (index === -1) return { x: comp.x, y: comp.y };
            const total = connectors.length;
            const y = comp.y + 24 + (height - 24) / (total + 1) * (index + 1);
            const isInputOnLeft = !comp.flipped;
            
            if (comp.type === 'Permutador') {
                 const isPrimary = name.includes('primario');
                 const yOffset = isPrimary ? -10 : 10;
                 const yPos = comp.y + height / 2 + yOffset;
                 if (type === 'input') return { x: isInputOnLeft ? comp.x : comp.x + COMPONENT_WIDTH, y: yPos };
                 else return { x: isInputOnLeft ? comp.x + COMPONENT_WIDTH : comp.x, y: yPos };
            }

            if (type === 'input') { return { x: isInputOnLeft ? comp.x : comp.x + COMPONENT_WIDTH, y }; } 
            else { return { x: isInputOnLeft ? comp.x + COMPONENT_WIDTH : comp.x, y }; }
        }

        function drawConnectors(comp) {
            const inputs = getComponentConnectors(comp, 'input');
            inputs.forEach(name => {
                const pos = getConnectorPos(comp, 'input', name);
                ctx.beginPath(); ctx.arc(pos.x, pos.y, CONNECTOR_RADIUS, 0, 2 * Math.PI); ctx.fillStyle = '#3b82f6'; ctx.fill();
            });
            const outputs = getComponentConnectors(comp, 'output');
            outputs.forEach(name => {
                const pos = getConnectorPos(comp, 'output', name);
                ctx.beginPath(); ctx.arc(pos.x, pos.y, CONNECTOR_RADIUS, 0, 2 * Math.PI); ctx.fillStyle = '#ef4444'; ctx.fill();
            });
        }

        function getBezierMidPoint(conn) {
             const fromComp = components.find(c => c.id === conn.from.id), toComp = components.find(c => c.id === conn.to.id);
            if (!fromComp || !toComp) return null;
            const p0 = getConnectorPos(fromComp, 'output', conn.from.connector), p3 = getConnectorPos(toComp, 'input', conn.to.connector);
            const p1 = { x: p0.x + 50, y: p0.y }, p2 = { x: p3.x - 50, y: p3.y };
            const t = 0.5;
            const x = Math.pow(1 - t, 3) * p0.x + 3 * Math.pow(1 - t, 2) * t * p1.x + 3 * (1 - t) * t * t * p2.x + t * t * t * p3.x;
            const y = Math.pow(1 - t, 3) * p0.y + 3 * Math.pow(1 - t, 2) * t * p1.y + 3 * (1 - t) * t * t * p2.y + t * t * t * p3.y;
            return {x, y};
        }

        function drawConnectionData(conn) {
            if (!steadyResultsAvailable) return;
            const fromComp = components.find(c => c.id === conn.from.id);
            if (!fromComp || fromComp.results.caudal === null) return;

            const pos = getBezierMidPoint(conn);
            if (!pos) return;
            
            const caudalTxt = `${fromComp.results.caudal.toFixed(2)} kg/s`;
            const tempTxt = `${fromComp.results.tempSaida.toFixed(1)}°C`;
            
            ctx.font = '11px Inter'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            const textWidth = Math.max(ctx.measureText(caudalTxt).width, ctx.measureText(tempTxt).width) + 8;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillRect(pos.x - textWidth / 2, pos.y - 14, textWidth, 28);
            ctx.fillStyle = '#1e293b'; // slate-800
            ctx.fillText(caudalTxt, pos.x, pos.y - 6);
            ctx.fillText(tempTxt, pos.x, pos.y + 8);
        }
        
        function drawConnection(conn) {
            const fromComp = components.find(c => c.id === conn.from.id), toComp = components.find(c => c.id === conn.to.id);
            if (!fromComp || !toComp) return;
            const fromPos = getConnectorPos(fromComp, 'output', conn.from.connector), toPos = getConnectorPos(toComp, 'input', conn.to.connector);
            ctx.beginPath(); ctx.moveTo(fromPos.x, fromPos.y); ctx.bezierCurveTo(fromPos.x + 50, fromPos.y, toPos.x - 50, toPos.y, toPos.x, toPos.y);
            const isSelected = conn === selectedConnection;
            ctx.strokeStyle = isSelected ? '#f59e0b' : '#64748b'; // amber-500 for selection
            ctx.lineWidth = isSelected ? 5 : 3;
            ctx.stroke();
        }

        function draw() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            ctx.save();
            ctx.clearRect(0, 0, rect.width, rect.height);
            ctx.translate(viewTransform.offsetX, viewTransform.offsetY);
            ctx.scale(viewTransform.scale, viewTransform.scale);
            drawGrid();
            connections.forEach(drawConnection);
            if (connectingFrom) {
                const fromPos = getConnectorPos(connectingFrom.component, 'output', connectingFrom.connector);
                const worldMouse = screenToWorld(mouse.x, mouse.y);
                ctx.beginPath(); ctx.moveTo(fromPos.x, fromPos.y); ctx.lineTo(worldMouse.x, worldMouse.y); ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 3; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
            }
            components.forEach(drawComponent);
            connections.forEach(drawConnectionData);
            ctx.restore();
        }
        
        // --- PROPRIEDADES E DADOS ---
        function showPropertiesPanel(comp) {
            selectedComponent = comp;
            propertiesPanel.innerHTML = '';
            propertiesPanel.classList.remove('w-0', 'p-0');
            propertiesPanel.classList.add('w-96', 'p-4'); 
            let content = `<h3 class="text-lg font-bold text-gray-700 mb-4 border-b pb-2">${comp.type}</h3><div class="space-y-4">`;
            
            // Generic parameter inputs
            const specialKeys = ['cargaVariavel', 'perfilDiario', 'perfilAnual', 'perfilArray', 'fuelType', 'energySource', 'numEntradas', 'numSaidas', 'tipo'];
            for (const key in comp.params) {
                if (specialKeys.includes(key)) continue;
                content += `<div><label for="param-${key}" class="block text-sm font-medium text-gray-700 capitalize">${key.replace(/([A-Z])/g, ' $1')}</label><input type="number" id="param-${key}" value="${comp.params[key]}" class="param-input mt-1"></div>`;
            }

            // Special inputs for specific components
            if(comp.type === 'Caldeira') {
                content += `<div><label for="param-fuelType" class="block text-sm font-medium text-gray-700">Combustível</label>
                <select id="param-fuelType" class="param-input mt-1">
                    <option value="Gás Natural" ${comp.params.fuelType === 'Gás Natural' ? 'selected' : ''}>Gás Natural</option>
                    <option value="Propano" ${comp.params.fuelType === 'Propano' ? 'selected' : ''}>Propano</option>
                </select></div>`;
            }

            if(comp.type === 'Produtor Genérico') {
                 content += `<div><label for="param-energySource" class="block text-sm font-medium text-gray-700">Fonte de Energia</label>
                <select id="param-energySource" class="param-input mt-1">
                    <option value="Eletricidade" ${comp.params.energySource === 'Eletricidade' ? 'selected' : ''}>Eletricidade</option>
                    <option value="Gás Natural" ${comp.params.energySource === 'Gás Natural' ? 'selected' : ''}>Gás Natural</option>
                    <option value="Propano" ${comp.params.energySource === 'Propano' ? 'selected' : ''}>Propano</option>
                </select></div>`;
            }

            if(comp.type === 'Permutador') {
                 content += `<div><label for="param-tipo" class="block text-sm font-medium text-gray-700">Tipo</label>
                 <select id="param-tipo" class="param-input mt-1">
                    <option value="Placas" ${comp.params.tipo === 'Placas' ? 'selected' : ''}>Placas</option>
                    <option value="Tubular" ${comp.params.tipo === 'Tubular' ? 'selected' : ''}>Tubular</option>
                 </select></div>`;
            }

            if(comp.type === 'Coletor') {
                content += `<div><label for="param-numEntradas" class="block text-sm font-medium text-gray-700">Nº de Entradas</label><input type="number" id="param-numEntradas" value="${comp.params.numEntradas}" min="1" class="param-input mt-1"></div>`;
                content += `<div><label for="param-numSaidas" class="block text-sm font-medium text-gray-700">Nº de Saídas</label><input type="number" id="param-numSaidas" value="${comp.params.numSaidas}" min="1" class="param-input mt-1"></div>`;
            }

            content += '</div>';

            if (comp.params.hasOwnProperty('cargaVariavel')) {
                content += `<div class="mt-4 pt-4 border-t">
                    <h4 class="text-md font-semibold text-gray-600 mb-2">Carga Variável</h4>
                    <div class="flex items-center mb-2">
                        <input type="checkbox" id="param-cargaVariavel" ${comp.params.cargaVariavel ? 'checked' : ''} class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                        <label for="param-cargaVariavel" class="ml-2 block text-sm text-gray-900">Ativar Carga Variável</label>
                    </div>
                    <button id="edit-variable-load-btn" class="w-full mt-2 bg-indigo-600 text-white py-2 rounded-lg hover:bg-indigo-700 transition">Editar Perfil de Carga</button>
                </div>`;
            }

            content += `<div class="mt-6 pt-4 border-t space-y-2"><button id="save-params-btn" class="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700 transition">Guardar</button><button id="delete-comp-btn" class="w-full bg-red-500 text-white py-2 rounded-lg hover:bg-red-600 transition">Apagar</button></div>`;
            propertiesPanel.innerHTML = content;
            
            const editLoadBtn = document.getElementById('edit-variable-load-btn');
            if (editLoadBtn) {
                editLoadBtn.addEventListener('click', () => showVariableLoadModal(comp));
            }

            document.getElementById('save-params-btn').addEventListener('click', () => saveComponentParams(comp));
            document.getElementById('delete-comp-btn').addEventListener('click', () => deleteComponent(comp.id));
            draw();
        }

        function hidePropertiesPanel() {
            selectedComponent = null;
            propertiesPanel.classList.remove('w-96', 'p-4');
            propertiesPanel.classList.add('w-0', 'p-0');
            propertiesPanel.innerHTML = '';
            draw();
        }
        
        function updateColetorConnectors(comp) {
            comp.inputs = [];
            for (let i = 1; i <= comp.params.numEntradas; i++) {
                comp.inputs.push(`in${i}`);
            }
            comp.outputs = [];
            for (let i = 1; i <= comp.params.numSaidas; i++) {
                comp.outputs.push(`out${i}`);
            }
        }

        function saveComponentParams(comp) {
            for (const key in comp.params) {
                const input = document.getElementById(`param-${key}`);
                if (['perfilDiario', 'perfilAnual', 'perfilArray'].includes(key)) continue; 
                
                if (input) {
                    if (input.type === 'checkbox') {
                        comp.params[key] = input.checked;
                    } else if (input.tagName === 'SELECT') {
                        comp.params[key] = input.value;
                    } else {
                        comp.params[key] = parseFloat(input.value) || 0;
                    }
                }
            }

            if (comp.type === 'Coletor') {
                updateColetorConnectors(comp);
                connections = connections.filter(c => {
                    if (c.from.id === comp.id && !comp.outputs.includes(c.from.connector)) return false;
                    if (c.to.id === comp.id && !comp.inputs.includes(c.to.connector)) return false;
                    return true;
                });
                draw();
            }

            showMessage(`${comp.type} atualizado.`);
            hidePropertiesPanel();
        }

        function deleteComponent(compId) {
            components = components.filter(c => c.id !== compId);
            connections = connections.filter(c => c.id !== compId);
            hidePropertiesPanel();
            draw();
        }

        function showDataTable() {
            const container = document.getElementById('data-table-container');
            
            // Table 1: Energy Consumption
            let consumptionTableHTML = `<h3 class="text-lg font-semibold mb-2 text-gray-800">Consumos Anuais de Energia por Equipamento (Resultados da Simulação Dinâmica)</h3>
                <table><thead><tr>
                    <th>ID</th><th>Tipo</th>
                    <th>Eletricidade (kWh)</th><th>Gás Natural (kWh)</th><th>Propano (kWh)</th>
                </tr></thead><tbody>`;

            components.forEach(comp => {
                const totals = comp.totalConsumptions || { eletrico: 0, gasNatural: 0, propano: 0 };
                consumptionTableHTML += `<tr>
                    <td>${comp.id}</td>
                    <td class="font-bold">${comp.type}</td>
                    <td>${(totals.eletrico / 1000).toFixed(2)}</td>
                    <td>${(totals.gasNatural / 1000).toFixed(2)}</td>
                    <td>${(totals.propano / 1000).toFixed(2)}</td>
                </tr>`;
            });
            consumptionTableHTML += '</tbody></table>';

            // Table 2: Equipment Characteristics
            let characteristicsTableHTML = `<h3 class="text-lg font-semibold mt-6 mb-2 text-gray-800">Características dos Equipamentos</h3>
                <table><thead><tr>
                    <th>ID</th><th>Tipo</th><th>Parâmetros</th>
                </tr></thead><tbody>`;

            const paramFilter = ['perfilDiario', 'perfilAnual', 'perfilArray'];
            components.forEach(comp => {
                const params = Object.entries(comp.params)
                    .filter(([key]) => !paramFilter.includes(key))
                    .map(([key, value]) => {
                        const formattedKey = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
                        return `<strong>${formattedKey}:</strong> ${value}`;
                    })
                    .join('<br>');
                    
                characteristicsTableHTML += `<tr>
                    <td>${comp.id}</td>
                    <td class="font-bold">${comp.type}</td>
                    <td>${params}</td>
                </tr>`;
            });
            characteristicsTableHTML += '</tbody></table>';

            container.innerHTML = consumptionTableHTML + characteristicsTableHTML;
            tableModal.classList.remove('hidden');
        }

        function hideDataTable() {
            tableModal.classList.add('hidden');
        }

        function updateDailyLoadTotal() {
            let totalWh = 0;
            for (let i = 0; i < 24; i++) {
                const input = dailyLoadInputsContainer.querySelector(`#modal-h${i}`);
                if (input) {
                    totalWh += parseFloat(input.value) || 0;
                }
            }
            const totalKWh = totalWh / 1000;
            dailyLoadTotalSpan.textContent = totalKWh.toLocaleString('pt-PT', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        function updateAnnualLoadTotal() {
            const annualValuesStr = modalAnnualProfileTextarea.value.trim();
            if (!annualValuesStr) {
                annualLoadTotalSpan.textContent = '0.00';
                return;
            }
            const profileArray = annualValuesStr.split(',').map(s => parseFloat(s.trim()));
            const totalWh = profileArray.reduce((sum, val) => sum + (isNaN(val) ? 0 : val), 0);
            const totalKWh = totalWh / 1000;
            annualLoadTotalSpan.textContent = totalKWh.toLocaleString('pt-PT', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }


        function showVariableLoadModal(comp) {
            editingLoadComponent = comp;
            variableLoadModal.classList.remove('hidden');

            dailyLoadInputsContainer.innerHTML = ''; 
            const dailyProfile = comp.params.perfilDiario ? comp.params.perfilDiario.split(',').map(s => s.trim()) : Array(24).fill(0);
            for (let i = 0; i < 24; i++) {
                const inputWrapper = document.createElement('div');
                inputWrapper.className = 'flex items-center';
                inputWrapper.innerHTML = `<label for="modal-h${i}" class="text-xs mr-1 w-8 text-right">${i}h:</label><input type="number" id="modal-h${i}" value="${dailyProfile[i] || 0}" class="w-full p-1 border border-gray-300 rounded-md text-xs">`;
                const input = inputWrapper.querySelector('input');
                input.addEventListener('input', () => {
                     const data = [];
                     for(let j=0; j<24; j++) {
                        data.push(parseFloat(dailyLoadInputsContainer.querySelector(`#modal-h${j}`).value) || 0);
                     }
                     renderLoadChartDaily(data);
                     updateDailyLoadTotal();
                });
                dailyLoadInputsContainer.appendChild(inputWrapper);
            }
            
            modalAnnualProfileTextarea.value = comp.params.perfilAnual || '';
            
            updateDailyLoadTotal();
            updateAnnualLoadTotal();

            const activeTab = document.querySelector('#load-profile-tabs button.tab-btn-active');
            if (activeTab && activeTab.dataset.tab === 'anual') {
                 loadChartTitle.textContent = 'Visualização do Perfil Anual (Soma Mensal)';
                 renderLoadChartAnnual(modalAnnualProfileTextarea.value);
            } else {
                 loadChartTitle.textContent = 'Visualização do Perfil Diário';
                 renderLoadChartDaily(dailyProfile.map(Number));
            }
        }

        function hideVariableLoadModal() {
            variableLoadModal.classList.add('hidden');
            editingLoadComponent = null;
        }

        function saveVariableLoadParams() {
            if (!editingLoadComponent) return;

            const dailyValues = [];
            for(let i=0; i<24; i++) {
                dailyValues.push(dailyLoadInputsContainer.querySelector(`#modal-h${i}`).value || '0');
            }
            editingLoadComponent.params.perfilDiario = dailyValues.join(',');
            
            const annualValuesStr = modalAnnualProfileTextarea.value.trim();
            editingLoadComponent.params.perfilAnual = annualValuesStr; 
            
            if (annualValuesStr) {
                const profileArray = annualValuesStr.split(',').map(s => parseFloat(s.trim()));
                const validNumbers = profileArray.filter(n => !isNaN(n));

                if(validNumbers.length !== profileArray.length) {
                    showMessage('Aviso: O perfil anual contém valores não numéricos.', true);
                    editingLoadComponent.params.perfilArray = [];
                } else if (validNumbers.length !== 8760) {
                    showMessage(`Aviso: Perfil anual deve ter 8760 valores. Fornecidos: ${validNumbers.length}.`, true);
                    editingLoadComponent.params.perfilArray = [];
                } else {
                    editingLoadComponent.params.perfilArray = validNumbers; 
                    showMessage('Perfil anual de 8760h importado com sucesso.');
                }
            } else {
                 editingLoadComponent.params.perfilArray = [];
                 const dailyNumeric = editingLoadComponent.params.perfilDiario.split(',').map(Number);
                 for(let i=0; i < 365; i++) {
                    editingLoadComponent.params.perfilArray.push(...dailyNumeric);
                 }
            }
            hideVariableLoadModal();
        }

        function renderLoadChartDaily(data) {
            if (loadChartInstance) {
                loadChartInstance.destroy();
            }
            const labels = Array.from({length: 24}, (_, i) => `${i}h`);
            loadChartInstance = new Chart(loadChartCanvas, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Carga Horária (W)',
                        data: data,
                        backgroundColor: 'rgba(79, 70, 229, 0.7)', // indigo-600
                    }]
                },
                options: {
                    scales: { y: { beginAtZero: true, title: { display: true, text: 'Potência (W)' } } },
                    responsive: true, maintainAspectRatio: false,
                    plugins: { legend: { display: false } }
                }
            });
        }
        
        function renderLoadChartAnnual(dataString) {
            if (loadChartInstance) { loadChartInstance.destroy(); }
            const stringArray = dataString.split(',');
            
            let monthlyTotals = Array(12).fill(0);
            let errorMessage = '';
            
            if (stringArray.length > 1 && stringArray.some(s => s.trim() !== '' && isNaN(parseFloat(s)))) {
               errorMessage = 'Aviso: Dados anuais contêm valores não numéricos.';
            }
            
            const validNumbers = stringArray.map(s => parseFloat(s.trim())).filter(n => !isNaN(n));

            if (validNumbers.length > 0 && validNumbers.length !== 8760) {
               errorMessage = `Aviso: Perfil deve ter 8760 valores. Fornecidos: ${validNumbers.length}.`;
            }

            if (!errorMessage && validNumbers.length === 8760) {
                const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                let hourCounter = 0;
                for (let i = 0; i < 12; i++) {
                    const hoursInThisMonth = daysInMonth[i] * 24;
                    const monthSlice = validNumbers.slice(hourCounter, hourCounter + hoursInThisMonth);
                    monthlyTotals[i] = monthSlice.reduce((a, b) => a + b, 0) / 1000; // to kWh
                    hourCounter += hoursInThisMonth;
                }
            }
            
            const monthLabels = ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"];
            loadChartInstance = new Chart(loadChartCanvas, {
                type: 'bar',
                data: {
                    labels: monthLabels,
                    datasets: [{
                        label: 'Carga Mensal (kWh)', data: monthlyTotals,
                        backgroundColor: 'rgba(168, 85, 247, 0.7)', // purple-500
                    }]
                },
                options: {
                    scales: { y: { beginAtZero: true, title: { display: true, text: 'Energia (kWh)' } } },
                    responsive: true, maintainAspectRatio: false,
                    plugins: { legend: { display: false }, title: { display: !!errorMessage, text: errorMessage } }
                }
            });
        }

        // --- VALIDAÇÃO E SIMULAÇÃO ---
        function validateCircuit() {
            const errors = [];
            const producers = components.filter(c => componentTemplates[c.type].category === 'Produção');
            const pumps = components.filter(c => componentTemplates[c.type].category === 'Impulsão');
            const consumers = components.filter(c => componentTemplates[c.type].category === 'Consumo');

            if (producers.length === 0) errors.push('É necessário pelo menos um equipamento de "Produção".');
            if (pumps.length === 0) errors.push('É necessário pelo menos um equipamento de "Impulsão" (Bomba).');
            if (consumers.length === 0) errors.push('É necessário pelo menos um equipamento de "Consumo".');
            
            // Thermal Power Check
            const totalProductionPower = producers.reduce((sum, comp) => sum + comp.params.potencia, 0);
            const totalConsumptionPower = consumers.reduce((sum, comp) => sum + comp.params.potencia, 0);
            if (totalProductionPower < totalConsumptionPower) {
                errors.push(`Potência de produção nominal insuficiente. Produção: ${(totalProductionPower/1000).toFixed(1)} kW, Consumo: ${(totalConsumptionPower/1000).toFixed(1)} kW.`);
            }

            // Hydraulic & Closed Loop Check
            if (producers.length > 0 && pumps.length > 0) {
                 const simulationOrder = [], visited = new Set();
                let currentComp = producers[0];
                while (currentComp && !visited.has(currentComp.id)) {
                    simulationOrder.push(currentComp); 
                    visited.add(currentComp.id);
                    let connection;
                    if (currentComp.type === 'Permutador') { connection = connections.find(c => c.from.id === currentComp.id && c.from.connector === 'primario_out'); }
                    else if (currentComp.type === 'Coletor') { connection = connections.find(c => c.from.id === currentComp.id && c.from.connector === 'out1'); }
                    else { connection = connections.find(c => c.from.id === currentComp.id); }
                    currentComp = connection ? components.find(c => c.id === connection.to.id) : null;
                }

                if (currentComp && currentComp.id === producers[0].id) { // Path is a closed loop
                    const pumpInCircuit = simulationOrder.find(c => c.type === 'Bomba');
                    if(pumpInCircuit){
                        const totalPressureDrop = simulationOrder.reduce((sum, comp) => sum + (comp.params.perdaCarga || 0), 0);
                        if (totalPressureDrop > pumpInCircuit.params.alturaManometrica) {
                            errors.push(`Altura manométrica da bomba insuficiente. Bomba: ${pumpInCircuit.params.alturaManometrica} kPa, Perda de Carga do Circuito: ${totalPressureDrop.toFixed(1)} kPa.`);
                        }
                    }
                } else {
                     errors.push('O circuito não está fechado. O último equipamento deve ligar-se ao primeiro equipamento de produção.');
                }
            }
            return errors;
        }

        function showValidationWarning(errors) {
            validationErrorsList.innerHTML = errors.map(e => `<li>${e}</li>`).join('');
            validationModal.classList.remove('hidden');
        }

        function runSteadyStateCalculation(isDynamicStep = false) {
            steadyResultsAvailable = false;
            components.forEach(c => c.results = { 
                caudal: null, tempEntrada: null, tempSaida: null, potencia: null,
                consumoEletrico: 0, consumoGasNatural: 0, consumoPropano: 0 
            });
            
            const tempExterior = parseFloat(document.getElementById('tempExterior').value) || 10;
            const producer = components.find(c => componentTemplates[c.type].category === 'Produção');
            const pump = components.find(c => componentTemplates[c.type].category === 'Impulsão');
            
            const simulationOrder = [], visited = new Set();
            let currentComp = producer;
            while (currentComp && !visited.has(currentComp.id)) {
                simulationOrder.push(currentComp); 
                visited.add(currentComp.id);
                
                let connection;
                if (currentComp.type === 'Permutador') {
                    connection = connections.find(c => c.from.id === currentComp.id && c.from.connector === 'primario_out');
                } else if (currentComp.type === 'Coletor') {
                    connection = connections.find(c => c.from.id === currentComp.id && c.from.connector === 'out1');
                }
                else {
                    connection = connections.find(c => c.from.id === currentComp.id);
                }

                currentComp = connection ? components.find(c => c.id === connection.to.id) : null;
            }
            
            const lastComp = simulationOrder[simulationOrder.length - 1];
            const loopConnection = connections.find(c => c.from.id === lastComp?.id && c.to.id === producer.id);
            const valvula = simulationOrder.find(c => c.type === 'Válvula de Regulação');
            const fatorAbertura = valvula ? Math.max(0, Math.min(1, valvula.params.abertura / 100)) : 1;
            const caudal = pump.params.caudal * fatorAbertura;
            let tempRetorno = loopConnection ? 20 : producer.params.tempSaida; 
            
            for(let i = 0; i < 5; i++) {
                let currentTemp = tempRetorno;
                simulationOrder.forEach(comp => {
                    comp.results.caudal = caudal; comp.results.tempEntrada = currentTemp;
                    if (caudal === 0) { comp.results.tempSaida = currentTemp; comp.results.potencia = 0; return; }
                    
                    switch (comp.type) {
                        case 'Caldeira': comp.results.tempSaida = comp.params.tempSaida; break;
                        case 'Bomba de Calor': {
                            const effectiveCOP = comp.params.COP - (7 - tempExterior) * 0.05;
                            const potHP = comp.params.potencia * (effectiveCOP > 1 ? effectiveCOP : 1);
                            comp.results.tempSaida = currentTemp + (potHP / (caudal * SPECIFIC_HEAT_WATER));
                            comp.results.potencia = potHP;
                            if (potHP > 0 && effectiveCOP > 0) comp.results.consumoEletrico = potHP / effectiveCOP;
                            break;
                        }
                        case 'Chiller': {
                            const efficiencyFactor = Math.max(0.1, 1 - (tempExterior - 35) * 0.03);
                            const effectiveCoolingPower = comp.params.potencia * efficiencyFactor;
                            comp.results.tempSaida = currentTemp - (effectiveCoolingPower / (caudal * SPECIFIC_HEAT_WATER));
                            comp.results.potencia = -effectiveCoolingPower;
                            const effectiveEER = comp.params.EER * efficiencyFactor;
                            if (effectiveCoolingPower > 0 && effectiveEER > 0) comp.results.consumoEletrico = effectiveCoolingPower / effectiveEER;
                            break;
                        }
                        case 'Produtor Genérico': {
                            let potenciaConsumo = comp.params.potencia;
                             if (dynamicSimState.running && comp.params.cargaVariavel && comp.params.perfilArray?.length === 8760) {
                                potenciaConsumo = comp.params.perfilArray[dynamicSimState.hour - 1] || 0;
                            }
                            comp.results.tempSaida = currentTemp + (potenciaConsumo / (caudal * SPECIFIC_HEAT_WATER));
                            comp.results.potencia = potenciaConsumo;
                            if (comp.params.energySource === 'Eletricidade') comp.results.consumoEletrico = potenciaConsumo;
                            else if (comp.params.energySource === 'Gás Natural') comp.results.consumoGasNatural = potenciaConsumo;
                            else if (comp.params.energySource === 'Propano') comp.results.consumoPropano = potenciaConsumo;
                            break;
                        }
                        case 'Bomba': comp.results.tempSaida = currentTemp; comp.results.potencia = 0; comp.results.consumoEletrico = comp.params.potEletrica; break;
                        case 'Tubo': {
                            const deltaT_tubo = currentTemp - tempExterior;
                            const perdaTubo = comp.params.comprimento * comp.params.perdaTermica * deltaT_tubo;
                            comp.results.tempSaida = currentTemp - (perdaTubo / (caudal * SPECIFIC_HEAT_WATER));
                            comp.results.potencia = -perdaTubo;
                            break;
                        }
                        case 'Válvula de Regulação': comp.results.tempSaida = currentTemp; comp.results.potencia = 0; break;
                        case 'Radiador': case 'Carga Genérica': case 'Permutador': {
                            let potenciaConsumo = comp.params.potencia;
                            if (!comp.type.includes('Permutador') && dynamicSimState.running && comp.params.cargaVariavel && comp.params.perfilArray?.length === 8760) {
                                potenciaConsumo = comp.params.perfilArray[dynamicSimState.hour - 1] || 0;
                            }
                            comp.results.tempSaida = currentTemp - (potenciaConsumo / (caudal * SPECIFIC_HEAT_WATER));
                            comp.results.potencia = -potenciaConsumo; 
                            break;
                        }
                        case 'Unidade de Tratamento de Ar': {
                            let potenciaConsumo = comp.params.potencia;
                            if (dynamicSimState.running && comp.params.cargaVariavel && comp.params.perfilArray?.length === 8760) {
                                potenciaConsumo = comp.params.perfilArray[dynamicSimState.hour - 1] || 0;
                            }
                            comp.results.tempSaida = currentTemp - (potenciaConsumo / (caudal * SPECIFIC_HEAT_WATER));
                            comp.results.potencia = -potenciaConsumo;
                            comp.results.consumoEletrico = comp.params.potEletrica;
                            break;
                        }
                        case 'Acumulador': case 'Depósito de Inércia': case 'Coletor':
                            comp.results.tempSaida = currentTemp; comp.results.potencia = 0; break;
                    }
                    currentTemp = comp.results.tempSaida;
                });
                if(loopConnection) tempRetorno = currentTemp; else break;
            }

             if (loopConnection && producer.type === 'Caldeira') {
                const potNec = caudal * SPECIFIC_HEAT_WATER * (producer.params.tempSaida - tempRetorno);
                producer.results.potencia = potNec > 0 ? potNec : 0;
                producer.results.consumoEletrico = producer.params.potEletrica;
                const fuelConsumption = potNec > 0 ? potNec / producer.params.rendimento : 0;
                if (producer.params.fuelType === 'Gás Natural') producer.results.consumoGasNatural = fuelConsumption;
                else if (producer.params.fuelType === 'Propano') producer.results.consumoPropano = fuelConsumption;
             }

            steadyResultsAvailable = true;
            if(!isDynamicStep) draw();
        }

        function startDynamicSimulation() {
            const validationErrors = validateCircuit();
            if (validationErrors.length > 0) {
                showValidationWarning(validationErrors);
                return;
            }
            if (dynamicSimState.running) return;

            if (dynamicSimState.hour >= 8760) {
                resetDynamicSimulation(true);
            }
            
            dynamicSimState.running = true;
            startDynamicBtn.classList.add('hidden');
            pauseDynamicBtn.classList.remove('hidden');
            
            if (dynamicSimState.intervalId) clearInterval(dynamicSimState.intervalId);
            dynamicSimState.intervalId = setInterval(dynamicStep, dynamicSimState.speed);
        }
        
        function pauseDynamicSimulation() {
            if (!dynamicSimState.running) return;
            dynamicSimState.running = false;
            
            if (dynamicSimState.intervalId) {
                clearInterval(dynamicSimState.intervalId);
                dynamicSimState.intervalId = null;
            }

            pauseDynamicBtn.classList.add('hidden');
            startDynamicBtn.classList.remove('hidden');
            startDynamicBtn.textContent = 'Continuar';
        }

        function resetDynamicSimulation(clearUI = true) {
            pauseDynamicSimulation();

            dynamicSimState.hour = 0;
            dynamicSimState.totalTermica = 0;
            dynamicSimState.totalEletrica = 0;
            dynamicSimState.totalGasNatural = 0;
            dynamicSimState.totalPropano = 0;
            dynamicSimState.monthlyThermal.fill(0);
            dynamicSimState.monthlyElectric.fill(0);
            dynamicSimState.monthlyGasNatural.fill(0);
            dynamicSimState.monthlyPropano.fill(0);

            components.forEach(c => {
                if (!c.totalConsumptions) c.totalConsumptions = {};
                c.totalConsumptions.eletrico = 0;
                c.totalConsumptions.gasNatural = 0;
                c.totalConsumptions.propano = 0;
            });

            if(clearUI) {
                dynamicTimeDisplay.textContent = `Hora: 0 H`;
                totalTermicaDisplay.textContent = `0.0 kWh`;
                totalEletricoDisplay.textContent = `0.0 kWh`;
                totalGasNaturalDisplay.textContent = `0.0 kWh`;
                totalPropanoDisplay.textContent = `0.0 kWh`;
                startDynamicBtn.textContent = 'Sim. Dinâmica';
            }
            if (chartInstance) updateChart();
        }

        function dynamicStep() {
            if (!dynamicSimState.running) return;

            dynamicSimState.hour++;
            if (dynamicSimState.hour > 8760) {
                dynamicTimeDisplay.textContent = `Fim (8760 H)`;
                pauseDynamicSimulation();
                showMessage("Simulação dinâmica de 1 ano concluída.");
                return;
            }

            const dateString = getDateFromHour(dynamicSimState.hour);
            dynamicTimeDisplay.textContent = `Hora: ${dynamicSimState.hour} (${dateString})`;
            
            runSteadyStateCalculation(true);

            let consumoTermicoHora = 0;
            let consumoEletricoHora = 0;
            let consumoGasNaturalHora = 0;
            let consumoPropanoHora = 0;

            components.forEach(comp => {
                const potTermica = Math.abs(comp.results.potencia || 0);
                if (componentTemplates[comp.type].category === 'Consumo') {
                    consumoTermicoHora += potTermica;
                }
                
                const compConsumoEletrico = comp.results.consumoEletrico || 0;
                const compConsumoGasNatural = comp.results.consumoGasNatural || 0;
                const compConsumoPropano = comp.results.consumoPropano || 0;

                comp.totalConsumptions.eletrico += compConsumoEletrico;
                comp.totalConsumptions.gasNatural += compConsumoGasNatural;
                comp.totalConsumptions.propano += compConsumoPropano;
                
                consumoEletricoHora += compConsumoEletrico;
                consumoGasNaturalHora += compConsumoGasNatural;
                consumoPropanoHora += compConsumoPropano;
            });
            
            dynamicSimState.totalTermica += consumoTermicoHora;
            dynamicSimState.totalEletrica += consumoEletricoHora;
            dynamicSimState.totalGasNatural += consumoGasNaturalHora;
            dynamicSimState.totalPropano += consumoPropanoHora;

            const date = new Date(2024, 0, 1);
            date.setHours(date.getHours() + dynamicSimState.hour - 1);
            const monthIndex = date.getMonth();
            dynamicSimState.monthlyThermal[monthIndex] += consumoTermicoHora;
            dynamicSimState.monthlyElectric[monthIndex] += consumoEletricoHora;
            dynamicSimState.monthlyGasNatural[monthIndex] += consumoGasNaturalHora;
            dynamicSimState.monthlyPropano[monthIndex] += consumoPropanoHora;

            totalTermicaDisplay.textContent = `${(dynamicSimState.totalTermica / 1000).toFixed(1)} kWh`;
            totalEletricoDisplay.textContent = `${(dynamicSimState.totalEletrica / 1000).toFixed(1)} kWh`;
            totalGasNaturalDisplay.textContent = `${(dynamicSimState.totalGasNatural / 1000).toFixed(1)} kWh`;
            totalPropanoDisplay.textContent = `${(dynamicSimState.totalPropano / 1000).toFixed(1)} kWh`;
            
            if (chartInstance && !chartModal.classList.contains('hidden')) updateChart();

            draw();
        }
        
        function clearWorkspace() {
            resetDynamicSimulation(true);
            components = []; connections = []; nextId = 0; steadyResultsAvailable = false;
            hidePropertiesPanel(); draw(); 
        }

        function populateLibrary() {
            const categories = {}; const categoryOrder = ['Produção', 'Impulsão', 'Distribuição', 'Consumo', 'Acumulação'];
            for (const type in componentTemplates) {
                const template = componentTemplates[type];
                if (!categories[template.category]) categories[template.category] = [];
                categories[template.category].push(type);
            }
            categoryOrder.forEach(category => {
                if (!categories[category]) return;
                const categoryDiv = document.createElement('div'); categoryDiv.className = 'mb-4';
                const categoryTitle = document.createElement('h3'); categoryTitle.className = 'font-bold text-md text-blue-800 mb-2';
                categoryTitle.textContent = category; categoryDiv.appendChild(categoryTitle);
                categories[category].forEach(type => {
                    const template = componentTemplates[type];
                    const item = document.createElement('div');
                    item.className = 'component-library-item cursor-grab p-3 mb-2 rounded-lg border flex items-center space-x-3';
                    item.draggable = true; item.dataset.type = type; item.style.borderColor = template.color;
                    const colorIndicator = document.createElement('div'); colorIndicator.className = 'w-3 h-8 rounded';
                    colorIndicator.style.backgroundColor = template.color; item.appendChild(colorIndicator);
                    const text = document.createElement('span'); text.textContent = type; text.className = 'font-semibold'; item.appendChild(text);
                    item.addEventListener('dragstart', (e) => e.dataTransfer.setData('text/plain', type));
                    categoryDiv.appendChild(item);
                });
                libraryContainer.appendChild(categoryDiv);
            });
        }
        
        // --- GRÁFICO ---
        function showChartModal() {
            chartModal.classList.remove('hidden');
            renderChart();
        }
        function hideChartModal() {
            chartModal.classList.add('hidden');
        }
        function updateChart() {
            if (!chartInstance) return;
            chartInstance.data.datasets[0].data = dynamicSimState.monthlyThermal.map(v => v / 1000);
            chartInstance.data.datasets[1].data = dynamicSimState.monthlyElectric.map(v => v / 1000);
            chartInstance.data.datasets[2].data = dynamicSimState.monthlyGasNatural.map(v => v / 1000);
            chartInstance.data.datasets[3].data = dynamicSimState.monthlyPropano.map(v => v / 1000);
            chartInstance.update('none');
        }
        function renderChart() {
            if (chartInstance) {
                chartInstance.destroy();
            }
            const monthLabels = ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"];
            chartInstance = new Chart(chartCanvas, {
                type: 'bar',
                data: {
                    labels: monthLabels,
                    datasets: [
                        { label: 'Energia Térmica (kWh)', data: dynamicSimState.monthlyThermal.map(v => v / 1000), backgroundColor: 'rgba(59, 130, 246, 0.7)'}, // blue-500
                        { label: 'Consumo Elétrico (kWh)', data: dynamicSimState.monthlyElectric.map(v => v / 1000), backgroundColor: 'rgba(22, 163, 74, 0.7)'}, // green-600
                        { label: 'Gás Natural (kWh)', data: dynamicSimState.monthlyGasNatural.map(v => v / 1000), backgroundColor: 'rgba(245, 158, 11, 0.7)'}, // amber-500
                        { label: 'Propano (kWh)', data: dynamicSimState.monthlyPropano.map(v => v / 1000), backgroundColor: 'rgba(107, 114, 128, 0.7)'} // gray-500
                    ]
                },
                options: {
                    scales: { y: { beginAtZero: true, stacked: true, title: { display: true, text: 'Energia (kWh)' } }, x: { stacked: true } },
                    responsive: true, maintainAspectRatio: false,
                }
            });
        }

        // --- INICIALIZAÇÃO E EVENT LISTENERS ---
        window.addEventListener('resize', () => { setupCanvas(); draw(); });
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedConnection) {
                    connections = connections.filter(c => c !== selectedConnection);
                    selectedConnection = null; draw();
                } else if (selectedComponent) {
                    deleteComponent(selectedComponent.id);
                }
            }
        });
        
        simulateSteadyBtn.addEventListener('click', () => {
            if (dynamicSimState.running) { showMessage("Por favor, pare a simulação dinâmica primeiro.", true); return; }
            const validationErrors = validateCircuit();
            if (validationErrors.length > 0) {
                showValidationWarning(validationErrors);
                return;
            }
            runSteadyStateCalculation(false);
            showMessage("Simulação Steady-State concluída!");
        });

        startDynamicBtn.addEventListener('click', startDynamicSimulation);
        pauseDynamicBtn.addEventListener('click', pauseDynamicSimulation);
        showTableBtn.addEventListener('click', showDataTable);
        closeTableModalBtn.addEventListener('click', hideDataTable);
        showChartBtn.addEventListener('click', showChartModal);
        closeChartModalBtn.addEventListener('click', hideChartModal);
        closeValidationModalBtn.addEventListener('click', () => validationModal.classList.add('hidden'));
        clearBtn.addEventListener('click', clearWorkspace);
        clearResultsBtn.addEventListener('click', () => resetDynamicSimulation(true));
        
        closeLoadModalBtn.addEventListener('click', hideVariableLoadModal);
        saveLoadModalBtn.addEventListener('click', saveVariableLoadParams);

        const loadProfileTabs = document.querySelectorAll('#load-profile-tabs button');
        loadProfileTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                loadProfileTabs.forEach(t => t.classList.remove('tab-btn-active'));
                tab.classList.add('tab-btn-active');
                document.getElementById('load-tab-content-diario').classList.toggle('hidden', tab.dataset.tab !== 'diario');
                document.getElementById('load-tab-content-anual').classList.toggle('hidden', tab.dataset.tab !== 'anual');
                
                if (tab.dataset.tab === 'diario') {
                    loadChartTitle.textContent = 'Visualização do Perfil Diário';
                    const data = [];
                    for(let j=0; j<24; j++) {
                        data.push(parseFloat(dailyLoadInputsContainer.querySelector(`#modal-h${j}`).value) || 0);
                    }
                    renderLoadChartDaily(data);
                } else { // anual
                    loadChartTitle.textContent = 'Visualização do Perfil Anual (Soma Mensal)';
                    renderLoadChartAnnual(modalAnnualProfileTextarea.value);
                }
            });
        });
        modalAnnualProfileTextarea.addEventListener('input', () => {
            const activeTab = document.querySelector('#load-profile-tabs button.tab-btn-active');
            if (activeTab && activeTab.dataset.tab === 'anual') {
                renderLoadChartAnnual(modalAnnualProfileTextarea.value);
                updateAnnualLoadTotal();
            }
        });
        
        speedSelector.addEventListener('click', (e) => {
            if(e.target.tagName === 'BUTTON') {
                const newSpeed = parseInt(e.target.dataset.speed, 10);
                dynamicSimState.speed = newSpeed;

                speedSelector.querySelectorAll('button').forEach(btn => {
                    btn.classList.remove('speed-btn-active'); btn.classList.add('speed-btn-inactive');
                });
                e.target.classList.add('speed-btn-active');
                e.target.classList.remove('speed-btn-inactive');
                
                if (dynamicSimState.running) {
                    if (dynamicSimState.intervalId) clearInterval(dynamicSimState.intervalId);
                    dynamicSimState.intervalId = setInterval(dynamicStep, dynamicSimState.speed);
                }
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
            const worldPosBefore = screenToWorld(mouseX, mouseY);
            const zoomFactor = 1.1;
            const newScale = e.deltaY < 0 ? viewTransform.scale * zoomFactor : viewTransform.scale / zoomFactor;
            viewTransform.scale = Math.max(0.2, Math.min(3, newScale));
            const worldPosAfter = screenToWorld(mouseX, mouseY);
            viewTransform.offsetX += (worldPosAfter.x - worldPosBefore.x) * viewTransform.scale;
            viewTransform.offsetY += (worldPosAfter.y - worldPosBefore.y) * viewTransform.scale;
            draw();
        }, { passive: false });

        canvas.addEventListener('dragover', (e) => e.preventDefault());
        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const type = e.dataTransfer.getData('text/plain');
            const rect = canvas.getBoundingClientRect();
            const worldPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
            let x = Math.round((worldPos.x - COMPONENT_WIDTH / 2) / GRID_SIZE) * GRID_SIZE;
            let y = Math.round((worldPos.y - COMPONENT_HEIGHT / 2) / GRID_SIZE) * GRID_SIZE;
            const template = componentTemplates[type];
            if (template) {
                const newComp = {
                    id: nextId++, type: type, x: x, y: y, flipped: false,
                    params: JSON.parse(JSON.stringify(template.params)),
                    results: { caudal: null, tempEntrada: null, tempSaida: null, potencia: null },
                    totalConsumptions: { eletrico: 0, gasNatural: 0, propano: 0 }
                };
                if (type === 'Coletor') {
                    updateColetorConnectors(newComp);
                }
                components.push(newComp);
                draw();
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            mouse.down = true; mouse.dragMoved = false;
            const rect = canvas.getBoundingClientRect();
            const worldPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
            const mx = worldPos.x; const my = worldPos.y;
            
            for (const comp of [...components].reverse()) {
                const outputs = getComponentConnectors(comp, 'output');
                for(const name of outputs) {
                    const pos = getConnectorPos(comp, 'output', name);
                    if (Math.hypot(mx - pos.x, my - pos.y) < CONNECTOR_RADIUS + 2) { connectingFrom = { component: comp, connector: name }; draw(); return; }
                }
            }
            draggingComponent = components.find(c => {
                const height = getComponentHeight(c);
                return mx > c.x && mx < c.x + COMPONENT_WIDTH && my > c.y && my < c.y + height;
            });
            if(draggingComponent) { 
                draggingComponent.offsetX = mx - draggingComponent.x; 
                draggingComponent.offsetY = my - draggingComponent.y; 
                return; 
            }
            panning.active = true;
            panning.startX = e.clientX;
            panning.startY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect(); 
            mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top;
            if (mouse.down && (draggingComponent || panning.active)) { mouse.dragMoved = true; }
            if (draggingComponent) {
                const worldPos = screenToWorld(mouse.x, mouse.y);
                let newX = worldPos.x - draggingComponent.offsetX;
                let newY = worldPos.y - draggingComponent.offsetY;
                draggingComponent.x = Math.round(newX / GRID_SIZE) * GRID_SIZE;
                draggingComponent.y = Math.round(newY / GRID_SIZE) * GRID_SIZE;
                draw();
            } else if (connectingFrom) { 
                draw();
            } else if (panning.active) {
                const dx = e.clientX - panning.startX; const dy = e.clientY - panning.startY;
                viewTransform.offsetX += dx; viewTransform.offsetY += dy;
                panning.startX = e.clientX;
                panning.startY = e.clientY;
                draw();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            const worldPos = screenToWorld(e.clientX - e.target.getBoundingClientRect().left, e.clientY - e.target.getBoundingClientRect().top);
            const mx = worldPos.x; const my = worldPos.y;

            if (connectingFrom) {
                let connectionMade = false;
                for (const comp of components) {
                    if (comp.id === connectingFrom.component.id) continue;
                    const inputs = getComponentConnectors(comp, 'input');
                    for(const name of inputs) {
                        const pos = getConnectorPos(comp, 'input', name);
                        if (Math.hypot(mx - pos.x, my - pos.y) < CONNECTOR_RADIUS + 2) {
                            if (!connections.find(c => c.to.id === comp.id && c.to.connector === name)) {
                                connections.push({ from: { id: connectingFrom.component.id, connector: connectingFrom.connector }, to: { id: comp.id, connector: name } });
                                connectionMade = true;
                            } else { showMessage('Este conector de entrada já está a ser utilizado.', true); }
                            break;
                        }
                    }
                    if (connectionMade) break;
                }
            } 
            else if (!mouse.dragMoved) { 
                let clickedOnSomething = false;
                const clickedComp = components.find(c => {
                    const height = getComponentHeight(c);
                    return mx > c.x && mx < c.x + COMPONENT_WIDTH && my > c.y && my < c.y + height;
                });
                if (clickedComp) {
                    selectedConnection = null; showPropertiesPanel(clickedComp); clickedOnSomething = true;
                } else {
                    for (const conn of connections) {
                        const fromComp = components.find(c => c.id === conn.from.id);
                        const toComp = components.find(c => c.id === conn.to.id);
                        if (!fromComp || !toComp) continue;
                        const p0 = getConnectorPos(fromComp, 'output', conn.from.connector);
                        const p3 = getConnectorPos(toComp, 'input', conn.to.connector);
                        const p1 = { x: p0.x + 50, y: p0.y }; const p2 = { x: p3.x - 50, y: p3.y };
                        if (isPointOnBezier({x: mx, y: my}, p0, p1, p2, p3)) {
                            selectedConnection = conn;
                            if(selectedComponent) hidePropertiesPanel();
                            clickedOnSomething = true;
                            break;
                        }
                    }
                }
                if (!clickedOnSomething) {
                    if(selectedComponent) hidePropertiesPanel();
                    selectedConnection = null;
                }
            }
            draggingComponent = null; connectingFrom = null; mouse.down = false; mouse.dragMoved = false; panning.active = false;
            draw();
        });

        canvas.addEventListener('dblclick', (e) => {
            const worldPos = screenToWorld(e.clientX - e.target.getBoundingClientRect().left, e.clientY - e.target.getBoundingClientRect().top);
            const mx = worldPos.x; const my = worldPos.y;
            const clickedComp = components.find(c => {
                const height = getComponentHeight(c);
                return mx > c.x && mx < c.x + COMPONENT_WIDTH && my > c.y && my < c.y + height;
            });
            if (clickedComp) {
                const template = componentTemplates[clickedComp.type];
                if (template.inputs.length > 0 && template.outputs.length > 0) { clickedComp.flipped = !clickedComp.flipped; draw(); }
            }
        });

        setupCanvas();
        populateLibrary();
        draw();
    </script>
</body>
</html>

